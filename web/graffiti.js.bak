var saito = require('../../lib/saito/saito');
var ModTemplate = require('../../lib/templates/modtemplate');
const GraffitiAppspaceMain = require('./lib/appspace/main');



// These two functions read canvas pixel data and return a HEX color
function getPixel(context, x, y) {
    var p = context.getImageData(x+5, y+5, 1, 1).data;
    var hex = "#" + ("000000" + rgbToHex(p[0], p[1], p[2])).slice(-6);  
    return hex;
}
function rgbToHex(r, g, b) {
    if (r > 255 || g > 255 || b > 255)
        throw "Invalid color component";
    return ((r << 16) | (g << 8) | b).toString(16);
}

// given any point on the canvas, find the coordinates of
// the CELL those coordinates reside within
function getCellCoords(canvas, event, cellSize) {
    let rect   = canvas.getBoundingClientRect();
    let coords = [event.clientX - rect.left,
		  event.clientY - rect.top]
    // transform real numbered coords into top left corner of cell those coords reside in
    coords = coords.map(t => Math.floor(t));
    coords = coords.map(t => t - (t % cellSize));
    return coords;
    }



class Graffiti extends ModTemplate {

    constructor(app) {
	super(app);
	
	this.app            = app;
	this.name           = "Graffiti";
	this.appname        = "Graffiti";
	this.appPubKey      = "zEC6dxU9P1LFsHpc3BANqaPdRu4njmqbouCqgRQwFa6J"
	this.description    = "Email plugin that allows visual exploration and debugging of the Saito wallet.";
	this.categories     = "Utilities Core";
	this.icon	    = "fas fa-code";
	
	this.canvas         = "UNSET CANVAS";
	this.cellSize       = 10;
	this.lastHover      = null;
	this.leftButtonDown = false;

	this.queue = [];
	
	
	this.description = "A debug configuration dump for Saito";
	this.categories  = "Dev Utilities";

	app.keys.addKey( this.appPubKey , {watched: true});
	return this;
    }

    initializeCanvas(cellSize, cellsWide, cellsTall) {
	document.body.appendChild(document.createElement('canvas'));
	let canvas = document.getElementsByTagName('canvas')[0];
	this.canvas = canvas;
	this.cellSize = cellSize;
	
	canvas.width = cellSize * cellsWide;
	canvas.height = cellSize * cellsTall;
	canvas.style.display = 'block';
	canvas.style.margin  = ' 0 auto';

	let ctx = canvas.getContext('2d');
	ctx.fillStyle = "#ffffff";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

//	don't use GRID* except for testing - it breaks the color hover preview
//	this.drawGrid(cellSize, canvas.width, canvas.height);
    }
//  don't use the GRID*
    drawGrid(size, width, height) {
	let canvas = this.canvas;
	let ctx = canvas.getContext('2d');

	for (let i = 0; i <= width; i += size) {
	    ctx.moveTo(i, 0);
	    ctx.lineTo(i, height);
	    ctx.lineWidth = 1;
	    ctx.stroke();
	}

	for (let j = 0; j <= height; j += size) {
	    ctx.moveTo(0, j);
	    ctx.lineTo(width, j);
	    ctx.lineWidth = 1;
	    ctx.stroke();
	}
    }
    
    
    initializeHTML(app) {
	//app.keys.addKey( this.appPubKey , {watched: true});
	//	console.log(app.keys);
	// (cellSize (in pixels), cellsWide, cellsTall);
	this.initializeCanvas(30, 30, 30);
    }

    sendCell(event, app) {
	// get coordinates of mouse click relative to canvas
	let mymod = app.modules.returnModule("Graffiti");
	let rect = mymod.canvas.getBoundingClientRect();
	let coords = [event.clientX - rect.left,
		      event.clientY - rect.top]
	
	// transform real numbered coords into top left corner of cell those coords reside in
	coords = coords.map(t => Math.floor(t));
	coords = coords.map(t => t - (t % mymod.cellSize));
	
	// get color then pre-draw cell
	let color = document.getElementById("favcolor").value;
	let semiColor = color + "80"
	mymod.drawCell(coords, semiColor);

	// send data to chain
	let newtx = app.wallet.createUnsignedTransaction(mymod.appPubKey);
	
	newtx.msg.module = "Graffiti";
	newtx.msg.coords = coords;
	newtx.msg.color = color;
	
	newtx = app.wallet.signTransaction(newtx);
	app.network.propagateTransaction(newtx);
	return semiColor;
    }

    drawCell(coords, color) {
	let ctx = this.canvas.getContext('2d');
	// whiteout cell
	ctx.fillStyle = "#ffffff";
	ctx.fillRect(coords[0], coords[1], this.cellSize, this.cellSize);
	// then draw color in
	ctx.fillStyle = color;
	ctx.fillRect(coords[0], coords[1], this.cellSize, this.cellSize);
    }

    handleBrush(event, app, tapped=false) {
	let mymod = app.modules.returnModule("Graffiti");
	// get coordinates of cursor relative to canvas
	let coords = getCellCoords(mymod.canvas, event, mymod.cellSize)
	let color  = document.getElementById("favcolor").value;
	let newTile = false;
	let newColor = false;
	if (mymod.lastHover) {
	    newTile = JSON.stringify(coords) != JSON.stringify(mymod.lastHover['coords']);
	    newColor = color.slice(0, 7) != mymod.lastHover['color'].slice(0, 7);
	}

	let clicked = mymod.leftButtonDown || tapped;
	if (newTile || (newColor && clicked) ) {
	    // save the old color for later before drawing over it
	    let ctx = mymod.canvas.getContext('2d');
	    let oldColor = getPixel(ctx, coords[0], coords[1]);
	    
	    if (clicked) {
		if (tapped) {
		    oldColor = mymod.sendCell(event, app);
		}
		else {
		    
		}
//		mymod.sendQueue();
	    }
	    else {
		// draw over cnurrently hovered cell
		mymod.drawCell(coords, color);
		// replace previous hovered cell
		mymod.drawCell(mymod.lastHover['coords'], mymod.lastHover['color']);
	    }
	    // Set currently hovered cell as lastHover
	    mymod.lastHover = {'coords': coords,
			       'color' : oldColor
			      }
	}
    }
    
    attachEvents(app, mod) {
	
	let mymod = app.modules.returnModule("Graffiti");
  	let canvas = mymod.canvas;
	let ctx = canvas.getContext('2d');

	let zoom = 1;
	const ZOOM_SPEED = 0.1;
	
	canvas.addEventListener("wheel", function (e) {
	    if (e.deltaY > 0) {
		mymod.canvas.style.transform = `scale(${(zoom += ZOOM_SPEED)})`;
	    } else {
		mymod.canvas.style.transform = `scale(${(zoom -= ZOOM_SPEED)})`;
	    }
	});

	document.onmousedown = (e) => {
	    if (e.which === 1) {mymod.leftButtonDown = true}
	}

	document.onmouseup = (e) => {
	    if (e.which === 1) {mymod.leftButtonDown = false}
	}
	
	canvas.onmouseover = (e) => {
	    //
	    // save the color of the cell the cursor hovers over
	    //
	    let coords = getCellCoords(mymod.canvas, e, mymod.cellSize)
	    let color  = document.getElementById("favcolor").value;

	    mymod.lastHover = {'coords': coords,
			       'color' : getPixel(ctx, coords[0], coords[1])
			      }
	}
	
	canvas.onmouseout = (e) => {
	    //
	    // restore color of last cell the cursor hovered
	    //
	    if (!mymod.lastHover) { return; }
	    ctx.fillStyle = mymod.lastHover['color'];
	    ctx.fillRect(mymod.lastHover['coords'][0], mymod.lastHover['coords'][1], mymod.cellSize, mymod.cellSize);
	}

	// paints on click and drag
	canvas.onmousemove = (e) => {
	    this.handleBrush(e, app);
	}
	// paints on stationary click
	canvas.onclick = (e) => {
	    this.handleBrush(e, app, true);
	}

    }

    // get info and update page in here
    async onConfirmation(blk, tx, conf, app) {
	if (app.BROWSER == 0) { return; }

	if (conf == 0) {
	    let mymod = app.modules.returnModule("Graffiti")
	    let canvas = mymod.canvas;
	    let txmsg = tx.returnMessage();	

	    let coords = txmsg.coords;
	    let color  = txmsg.color;

	    mymod.drawCell(coords, color);

	}

    }

    /*
    // get info and update page in here
    async onConfirmation(blk, tx, conf, app) {

    //    let mymod = app.modules.returnModule(txmsg.module);
    //    if (mymod.browser_active == 0) {return;}

    attachEventsEmail(app, mod) {
    Console.log("attaching events");
    }
    */

}


module.exports = Graffiti;
